# Http面试题

## HTTP有哪些⽅法？

- HTTP1.0定义了三种请求⽅法： GET, POST 和 HEAD⽅法
- HTTP1.1新增了五种请求⽅法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

## 这些⽅法的具体作⽤是什么？

- GET: 通常⽤于请求服务器发送某些资源 
- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致. 该请求⽅法的⼀个使⽤场景是在 下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源 
- OPTIONS: ⽤于获取⽬的资源所⽀持的通信选项 
- POST: 发送数据给服务器 
- PUT: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式 
- DELETE: ⽤于删除指定的资源 
- PATCH: ⽤于对资源进⾏部分修改 
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器 
- TRACE: 回显服务器收到的请求，主要⽤于测试或诊断

## GET和POST有什么区别？

- 数据传输⽅式不同：GET请求通过URL传输数据，⽽POST的数据通过请求体传输。 
- 安全性不同：POST的数据因为在请求主体内，所以有⼀定的安全性保证，⽽GET的数据在URL中，通过历史记 录，缓存很容易查到数据信息。 
- 数据类型不同：GET只允许 ASCII 字符，⽽POST⽆限制 
- GET⽆害： 刷新、后退等浏览器操作GET请求是⽆害的，POST可能重复提交表单 
- 特性不同：GET是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽POST是⾮安全⾮幂等

## PUT和POST都是给服务器发送新增资源，有什么区别？

PUT 和POST⽅法的区别是,PUT⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽POST⽅法是⾮幂 等的。

除此之外还有⼀个区别，通常情况下，PUT的URI指向是具体单⼀资源，⽽POST可以指向资源集合。

举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤ `POST https://www.xxxx.com/articles` ， 这个请求的语义是，在articles的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。

⽽ `PUT https://www.xxxx.com/articles/820357430` 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』

## PUT和PATCH都是给服务器发送修改资源，有什么区别？

PUT和PATCH都是更新资源，⽽PATCH⽤来对已知资源进⾏局部更新。

⽐如我们有⼀篇⽂章的地址 `https://www.xxxx.com/articles/820357430` ,这篇⽂章的可以表示为:

```js
article = { 
  author: 'dxy', 
  creationDate: '2019-6-12', 
  content: '我写⽂章像蔡徐坤', 
  id: 820357430 
}
```

当我们要修改⽂章的作者时，我们可以直接发送 `PUT https://www.jianshu.com/articles/820357430` ，这个时候的数据应 该是:

```js
{ 
  author:'蔡徐坤', 
  creationDate: '2019-6-12', 
  content: '我写⽂章像蔡徐坤', 
  id: 820357430 
}
```

这种直接覆盖资源的修改⽅式应该⽤put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送 `PATCH https://www.jianshu.com/articles/820357430` ，这个时候只需要:

```js
{ 
  author:'蔡徐坤', 
}
```

## http的请求报⽂是什么样的？

- 请求⾏ 
- 请求头部
- 请求体

1. 请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。
2. 请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔
  - Accept 客户端可识别的内容类型列表
  - Content-Type
  - Origin
  - Referer
  - User-Agent  产⽣请求的浏览器类型
  - Host 请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机
3. 请求体: post put等请求携带的数据

## http的响应报⽂是什么样的？

- 响应⾏ 
- 响应头
- 响应体

1. 响应⾏： 由协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 
2. 响应头：响应部⾸组成 
3. 响应体：服务器响应的数据

## 聊⼀聊HTTP的部⾸有哪些？

## 聊⼀聊HTTP的状态码有哪些？

## 同样是重定向307，303，302的区别？

## HTTP的keep-alive是⼲什么的？

在早期的HTTP/1.0中，每次http请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，为了减少资源消耗， 缩短响应时间，就需要重⽤连接。在后来的HTTP/1.0中以及HTTP/1.1中，引⼊了重⽤连接的机制，就是在http请求头中 加⼊Connection: keep-alive来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。协议规定HTTP/1.0如果想要保持⻓连接，需要在请求头中加上Connection: keep-alive。

keep-alive的优点： 

- 较少的CPU和内存的使⽤（由于同时打开的连接的减少了） 
- 允许请求和应答的HTTP管线化 
- 降低拥塞控制 （TCP连接减少了） 
- 减少了后续请求的延迟（⽆需再进⾏握⼿） 
- 报告错误⽆需关闭TCP连

## [HTTPS是如何保证安全的？](./share/https)

## HTTP2相对于HTTP1.x有什么优势和特点？

1. ⼆进制分帧

帧：HTTP/2 数据通信的最⼩单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。 

流：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数ID HTTP/2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议解析起来更⾼效。

2. 头部压缩

HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。

- HTTP/2在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 
- ⾸部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 
- 每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

> 你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量

3. 服务器推送

服务端可以在发送⻚⾯HTML时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。例如服务端 可以主动把JS和CSS⽂件推送给客户端，⽽不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端。

4. 多路复⽤

HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的 TCP链接请求限制。

HTTP2中：

- 同域名下所有通信都在单个连接上完成。 
- 单个连接可以承载任意数量的双向数据流。 
- 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可 以重新组装

## [HTTP的缓存的过程是怎样的？](./share/cache)